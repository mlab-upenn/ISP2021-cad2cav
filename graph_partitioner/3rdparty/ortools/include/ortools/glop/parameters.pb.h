// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/glop/parameters.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ortools_2fglop_2fparameters_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ortools_2fglop_2fparameters_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ortools_2fglop_2fparameters_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ortools_2fglop_2fparameters_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ortools_2fglop_2fparameters_2eproto;
namespace operations_research {
namespace glop {
class GlopParameters;
struct GlopParametersDefaultTypeInternal;
extern GlopParametersDefaultTypeInternal _GlopParameters_default_instance_;
}  // namespace glop
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> ::operations_research::glop::GlopParameters* Arena::CreateMaybeMessage<::operations_research::glop::GlopParameters>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace operations_research {
namespace glop {

enum GlopParameters_ScalingAlgorithm : int {
  GlopParameters_ScalingAlgorithm_DEFAULT = 0,
  GlopParameters_ScalingAlgorithm_EQUILIBRATION = 1,
  GlopParameters_ScalingAlgorithm_LINEAR_PROGRAM = 2
};
bool GlopParameters_ScalingAlgorithm_IsValid(int value);
constexpr GlopParameters_ScalingAlgorithm GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MIN = GlopParameters_ScalingAlgorithm_DEFAULT;
constexpr GlopParameters_ScalingAlgorithm GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MAX = GlopParameters_ScalingAlgorithm_LINEAR_PROGRAM;
constexpr int GlopParameters_ScalingAlgorithm_ScalingAlgorithm_ARRAYSIZE = GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_ScalingAlgorithm_descriptor();
template<typename T>
inline const std::string& GlopParameters_ScalingAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlopParameters_ScalingAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlopParameters_ScalingAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlopParameters_ScalingAlgorithm_descriptor(), enum_t_value);
}
inline bool GlopParameters_ScalingAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlopParameters_ScalingAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlopParameters_ScalingAlgorithm>(
    GlopParameters_ScalingAlgorithm_descriptor(), name, value);
}
enum GlopParameters_SolverBehavior : int {
  GlopParameters_SolverBehavior_ALWAYS_DO = 0,
  GlopParameters_SolverBehavior_NEVER_DO = 1,
  GlopParameters_SolverBehavior_LET_SOLVER_DECIDE = 2
};
bool GlopParameters_SolverBehavior_IsValid(int value);
constexpr GlopParameters_SolverBehavior GlopParameters_SolverBehavior_SolverBehavior_MIN = GlopParameters_SolverBehavior_ALWAYS_DO;
constexpr GlopParameters_SolverBehavior GlopParameters_SolverBehavior_SolverBehavior_MAX = GlopParameters_SolverBehavior_LET_SOLVER_DECIDE;
constexpr int GlopParameters_SolverBehavior_SolverBehavior_ARRAYSIZE = GlopParameters_SolverBehavior_SolverBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_SolverBehavior_descriptor();
template<typename T>
inline const std::string& GlopParameters_SolverBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlopParameters_SolverBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlopParameters_SolverBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlopParameters_SolverBehavior_descriptor(), enum_t_value);
}
inline bool GlopParameters_SolverBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlopParameters_SolverBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlopParameters_SolverBehavior>(
    GlopParameters_SolverBehavior_descriptor(), name, value);
}
enum GlopParameters_PricingRule : int {
  GlopParameters_PricingRule_DANTZIG = 0,
  GlopParameters_PricingRule_STEEPEST_EDGE = 1,
  GlopParameters_PricingRule_DEVEX = 2
};
bool GlopParameters_PricingRule_IsValid(int value);
constexpr GlopParameters_PricingRule GlopParameters_PricingRule_PricingRule_MIN = GlopParameters_PricingRule_DANTZIG;
constexpr GlopParameters_PricingRule GlopParameters_PricingRule_PricingRule_MAX = GlopParameters_PricingRule_DEVEX;
constexpr int GlopParameters_PricingRule_PricingRule_ARRAYSIZE = GlopParameters_PricingRule_PricingRule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_PricingRule_descriptor();
template<typename T>
inline const std::string& GlopParameters_PricingRule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlopParameters_PricingRule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlopParameters_PricingRule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlopParameters_PricingRule_descriptor(), enum_t_value);
}
inline bool GlopParameters_PricingRule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlopParameters_PricingRule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlopParameters_PricingRule>(
    GlopParameters_PricingRule_descriptor(), name, value);
}
enum GlopParameters_InitialBasisHeuristic : int {
  GlopParameters_InitialBasisHeuristic_NONE = 0,
  GlopParameters_InitialBasisHeuristic_BIXBY = 1,
  GlopParameters_InitialBasisHeuristic_TRIANGULAR = 2,
  GlopParameters_InitialBasisHeuristic_MAROS = 3
};
bool GlopParameters_InitialBasisHeuristic_IsValid(int value);
constexpr GlopParameters_InitialBasisHeuristic GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MIN = GlopParameters_InitialBasisHeuristic_NONE;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MAX = GlopParameters_InitialBasisHeuristic_MAROS;
constexpr int GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_ARRAYSIZE = GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_InitialBasisHeuristic_descriptor();
template<typename T>
inline const std::string& GlopParameters_InitialBasisHeuristic_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlopParameters_InitialBasisHeuristic>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlopParameters_InitialBasisHeuristic_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlopParameters_InitialBasisHeuristic_descriptor(), enum_t_value);
}
inline bool GlopParameters_InitialBasisHeuristic_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlopParameters_InitialBasisHeuristic* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlopParameters_InitialBasisHeuristic>(
    GlopParameters_InitialBasisHeuristic_descriptor(), name, value);
}
enum GlopParameters_CostScalingAlgorithm : int {
  GlopParameters_CostScalingAlgorithm_NO_COST_SCALING = 0,
  GlopParameters_CostScalingAlgorithm_CONTAIN_ONE_COST_SCALING = 1,
  GlopParameters_CostScalingAlgorithm_MEAN_COST_SCALING = 2,
  GlopParameters_CostScalingAlgorithm_MEDIAN_COST_SCALING = 3
};
bool GlopParameters_CostScalingAlgorithm_IsValid(int value);
constexpr GlopParameters_CostScalingAlgorithm GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_MIN = GlopParameters_CostScalingAlgorithm_NO_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_MAX = GlopParameters_CostScalingAlgorithm_MEDIAN_COST_SCALING;
constexpr int GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_ARRAYSIZE = GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_CostScalingAlgorithm_descriptor();
template<typename T>
inline const std::string& GlopParameters_CostScalingAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlopParameters_CostScalingAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlopParameters_CostScalingAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlopParameters_CostScalingAlgorithm_descriptor(), enum_t_value);
}
inline bool GlopParameters_CostScalingAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlopParameters_CostScalingAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlopParameters_CostScalingAlgorithm>(
    GlopParameters_CostScalingAlgorithm_descriptor(), name, value);
}
// ===================================================================

class GlopParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:operations_research.glop.GlopParameters) */ {
 public:
  inline GlopParameters() : GlopParameters(nullptr) {}
  ~GlopParameters() override;
  explicit constexpr GlopParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlopParameters(const GlopParameters& from);
  GlopParameters(GlopParameters&& from) noexcept
    : GlopParameters() {
    *this = ::std::move(from);
  }

  inline GlopParameters& operator=(const GlopParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlopParameters& operator=(GlopParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlopParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlopParameters* internal_default_instance() {
    return reinterpret_cast<const GlopParameters*>(
               &_GlopParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GlopParameters& a, GlopParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GlopParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlopParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlopParameters* New() const final {
    return new GlopParameters();
  }

  GlopParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlopParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlopParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GlopParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlopParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "operations_research.glop.GlopParameters";
  }
  protected:
  explicit GlopParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GlopParameters_ScalingAlgorithm ScalingAlgorithm;
  static constexpr ScalingAlgorithm DEFAULT =
    GlopParameters_ScalingAlgorithm_DEFAULT;
  static constexpr ScalingAlgorithm EQUILIBRATION =
    GlopParameters_ScalingAlgorithm_EQUILIBRATION;
  static constexpr ScalingAlgorithm LINEAR_PROGRAM =
    GlopParameters_ScalingAlgorithm_LINEAR_PROGRAM;
  static inline bool ScalingAlgorithm_IsValid(int value) {
    return GlopParameters_ScalingAlgorithm_IsValid(value);
  }
  static constexpr ScalingAlgorithm ScalingAlgorithm_MIN =
    GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MIN;
  static constexpr ScalingAlgorithm ScalingAlgorithm_MAX =
    GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MAX;
  static constexpr int ScalingAlgorithm_ARRAYSIZE =
    GlopParameters_ScalingAlgorithm_ScalingAlgorithm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScalingAlgorithm_descriptor() {
    return GlopParameters_ScalingAlgorithm_descriptor();
  }
  template<typename T>
  static inline const std::string& ScalingAlgorithm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScalingAlgorithm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScalingAlgorithm_Name.");
    return GlopParameters_ScalingAlgorithm_Name(enum_t_value);
  }
  static inline bool ScalingAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScalingAlgorithm* value) {
    return GlopParameters_ScalingAlgorithm_Parse(name, value);
  }

  typedef GlopParameters_SolverBehavior SolverBehavior;
  static constexpr SolverBehavior ALWAYS_DO =
    GlopParameters_SolverBehavior_ALWAYS_DO;
  static constexpr SolverBehavior NEVER_DO =
    GlopParameters_SolverBehavior_NEVER_DO;
  static constexpr SolverBehavior LET_SOLVER_DECIDE =
    GlopParameters_SolverBehavior_LET_SOLVER_DECIDE;
  static inline bool SolverBehavior_IsValid(int value) {
    return GlopParameters_SolverBehavior_IsValid(value);
  }
  static constexpr SolverBehavior SolverBehavior_MIN =
    GlopParameters_SolverBehavior_SolverBehavior_MIN;
  static constexpr SolverBehavior SolverBehavior_MAX =
    GlopParameters_SolverBehavior_SolverBehavior_MAX;
  static constexpr int SolverBehavior_ARRAYSIZE =
    GlopParameters_SolverBehavior_SolverBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SolverBehavior_descriptor() {
    return GlopParameters_SolverBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& SolverBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SolverBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SolverBehavior_Name.");
    return GlopParameters_SolverBehavior_Name(enum_t_value);
  }
  static inline bool SolverBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SolverBehavior* value) {
    return GlopParameters_SolverBehavior_Parse(name, value);
  }

  typedef GlopParameters_PricingRule PricingRule;
  static constexpr PricingRule DANTZIG =
    GlopParameters_PricingRule_DANTZIG;
  static constexpr PricingRule STEEPEST_EDGE =
    GlopParameters_PricingRule_STEEPEST_EDGE;
  static constexpr PricingRule DEVEX =
    GlopParameters_PricingRule_DEVEX;
  static inline bool PricingRule_IsValid(int value) {
    return GlopParameters_PricingRule_IsValid(value);
  }
  static constexpr PricingRule PricingRule_MIN =
    GlopParameters_PricingRule_PricingRule_MIN;
  static constexpr PricingRule PricingRule_MAX =
    GlopParameters_PricingRule_PricingRule_MAX;
  static constexpr int PricingRule_ARRAYSIZE =
    GlopParameters_PricingRule_PricingRule_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PricingRule_descriptor() {
    return GlopParameters_PricingRule_descriptor();
  }
  template<typename T>
  static inline const std::string& PricingRule_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PricingRule>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PricingRule_Name.");
    return GlopParameters_PricingRule_Name(enum_t_value);
  }
  static inline bool PricingRule_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PricingRule* value) {
    return GlopParameters_PricingRule_Parse(name, value);
  }

  typedef GlopParameters_InitialBasisHeuristic InitialBasisHeuristic;
  static constexpr InitialBasisHeuristic NONE =
    GlopParameters_InitialBasisHeuristic_NONE;
  static constexpr InitialBasisHeuristic BIXBY =
    GlopParameters_InitialBasisHeuristic_BIXBY;
  static constexpr InitialBasisHeuristic TRIANGULAR =
    GlopParameters_InitialBasisHeuristic_TRIANGULAR;
  static constexpr InitialBasisHeuristic MAROS =
    GlopParameters_InitialBasisHeuristic_MAROS;
  static inline bool InitialBasisHeuristic_IsValid(int value) {
    return GlopParameters_InitialBasisHeuristic_IsValid(value);
  }
  static constexpr InitialBasisHeuristic InitialBasisHeuristic_MIN =
    GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MIN;
  static constexpr InitialBasisHeuristic InitialBasisHeuristic_MAX =
    GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MAX;
  static constexpr int InitialBasisHeuristic_ARRAYSIZE =
    GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InitialBasisHeuristic_descriptor() {
    return GlopParameters_InitialBasisHeuristic_descriptor();
  }
  template<typename T>
  static inline const std::string& InitialBasisHeuristic_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InitialBasisHeuristic>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InitialBasisHeuristic_Name.");
    return GlopParameters_InitialBasisHeuristic_Name(enum_t_value);
  }
  static inline bool InitialBasisHeuristic_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InitialBasisHeuristic* value) {
    return GlopParameters_InitialBasisHeuristic_Parse(name, value);
  }

  typedef GlopParameters_CostScalingAlgorithm CostScalingAlgorithm;
  static constexpr CostScalingAlgorithm NO_COST_SCALING =
    GlopParameters_CostScalingAlgorithm_NO_COST_SCALING;
  static constexpr CostScalingAlgorithm CONTAIN_ONE_COST_SCALING =
    GlopParameters_CostScalingAlgorithm_CONTAIN_ONE_COST_SCALING;
  static constexpr CostScalingAlgorithm MEAN_COST_SCALING =
    GlopParameters_CostScalingAlgorithm_MEAN_COST_SCALING;
  static constexpr CostScalingAlgorithm MEDIAN_COST_SCALING =
    GlopParameters_CostScalingAlgorithm_MEDIAN_COST_SCALING;
  static inline bool CostScalingAlgorithm_IsValid(int value) {
    return GlopParameters_CostScalingAlgorithm_IsValid(value);
  }
  static constexpr CostScalingAlgorithm CostScalingAlgorithm_MIN =
    GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_MIN;
  static constexpr CostScalingAlgorithm CostScalingAlgorithm_MAX =
    GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_MAX;
  static constexpr int CostScalingAlgorithm_ARRAYSIZE =
    GlopParameters_CostScalingAlgorithm_CostScalingAlgorithm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CostScalingAlgorithm_descriptor() {
    return GlopParameters_CostScalingAlgorithm_descriptor();
  }
  template<typename T>
  static inline const std::string& CostScalingAlgorithm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CostScalingAlgorithm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CostScalingAlgorithm_Name.");
    return GlopParameters_CostScalingAlgorithm_Name(enum_t_value);
  }
  static inline bool CostScalingAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CostScalingAlgorithm* value) {
    return GlopParameters_CostScalingAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUseDualSimplexFieldNumber = 31,
    kAllowSimplexAlgorithmChangeFieldNumber = 32,
    kPerturbCostsInDualSimplexFieldNumber = 53,
    kLogSearchProgressFieldNumber = 61,
    kFeasibilityRuleFieldNumber = 1,
    kOptimizationRuleFieldNumber = 2,
    kRefactorizationThresholdFieldNumber = 6,
    kRecomputeReducedCostsThresholdFieldNumber = 8,
    kRecomputeEdgesNormThresholdFieldNumber = 9,
    kPrimalFeasibilityToleranceFieldNumber = 10,
    kDualFeasibilityToleranceFieldNumber = 11,
    kRatioTestZeroThresholdFieldNumber = 12,
    kHarrisToleranceRatioFieldNumber = 13,
    kSmallPivotThresholdFieldNumber = 14,
    kMinimumAcceptablePivotFieldNumber = 15,
    kInitialBasisFieldNumber = 17,
    kBasisRefactorizationPeriodFieldNumber = 19,
    kDualizerThresholdFieldNumber = 21,
    kSolutionFeasibilityToleranceFieldNumber = 22,
    kSolveDualProblemFieldNumber = 20,
    kMarkowitzZlatevParameterFieldNumber = 29,
    kLuFactorizationPivotThresholdFieldNumber = 25,
    kMaxTimeInSecondsFieldNumber = 26,
    kMaxNumberOfIterationsFieldNumber = 27,
    kMarkowitzSingularityThresholdFieldNumber = 30,
    kUseScalingFieldNumber = 16,
    kUseTransposedMatrixFieldNumber = 18,
    kDynamicallyAdjustRefactorizationPeriodFieldNumber = 63,
    kProvideStrongOptimalGuaranteeFieldNumber = 24,
    kDevexWeightsResetPeriodFieldNumber = 33,
    kDualSmallPivotThresholdFieldNumber = 38,
    kPreprocessorZeroToleranceFieldNumber = 39,
    kObjectiveLowerLimitFieldNumber = 40,
    kObjectiveUpperLimitFieldNumber = 41,
    kChangeStatusToImpreciseFieldNumber = 58,
    kUsePreprocessingFieldNumber = 34,
    kUseMiddleProductFormUpdateFieldNumber = 35,
    kInitializeDevexWithColumnNormsFieldNumber = 36,
    kRandomSeedFieldNumber = 43,
    kDegenerateMinistepFactorFieldNumber = 42,
    kMaxDeterministicTimeFieldNumber = 45,
    kNumOmpThreadsFieldNumber = 44,
    kExploitSingletonColumnInInitialBasisFieldNumber = 37,
    kUseDedicatedDualFeasibilityAlgorithmFieldNumber = 62,
    kDropToleranceFieldNumber = 52,
    kRelativeCostPerturbationFieldNumber = 54,
    kRelativeMaxCostPerturbationFieldNumber = 55,
    kMaxNumberOfReoptimizationsFieldNumber = 56,
    kScalingMethodFieldNumber = 57,
    kCostScalingFieldNumber = 60,
    kInitialConditionNumberThresholdFieldNumber = 59,
  };
  // optional bool use_dual_simplex = 31 [default = false];
  bool has_use_dual_simplex() const;
  private:
  bool _internal_has_use_dual_simplex() const;
  public:
  void clear_use_dual_simplex();
  bool use_dual_simplex() const;
  void set_use_dual_simplex(bool value);
  private:
  bool _internal_use_dual_simplex() const;
  void _internal_set_use_dual_simplex(bool value);
  public:

  // optional bool allow_simplex_algorithm_change = 32 [default = false];
  bool has_allow_simplex_algorithm_change() const;
  private:
  bool _internal_has_allow_simplex_algorithm_change() const;
  public:
  void clear_allow_simplex_algorithm_change();
  bool allow_simplex_algorithm_change() const;
  void set_allow_simplex_algorithm_change(bool value);
  private:
  bool _internal_allow_simplex_algorithm_change() const;
  void _internal_set_allow_simplex_algorithm_change(bool value);
  public:

  // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
  bool has_perturb_costs_in_dual_simplex() const;
  private:
  bool _internal_has_perturb_costs_in_dual_simplex() const;
  public:
  void clear_perturb_costs_in_dual_simplex();
  bool perturb_costs_in_dual_simplex() const;
  void set_perturb_costs_in_dual_simplex(bool value);
  private:
  bool _internal_perturb_costs_in_dual_simplex() const;
  void _internal_set_perturb_costs_in_dual_simplex(bool value);
  public:

  // optional bool log_search_progress = 61 [default = false];
  bool has_log_search_progress() const;
  private:
  bool _internal_has_log_search_progress() const;
  public:
  void clear_log_search_progress();
  bool log_search_progress() const;
  void set_log_search_progress(bool value);
  private:
  bool _internal_log_search_progress() const;
  void _internal_set_log_search_progress(bool value);
  public:

  // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
  bool has_feasibility_rule() const;
  private:
  bool _internal_has_feasibility_rule() const;
  public:
  void clear_feasibility_rule();
  ::operations_research::glop::GlopParameters_PricingRule feasibility_rule() const;
  void set_feasibility_rule(::operations_research::glop::GlopParameters_PricingRule value);
  private:
  ::operations_research::glop::GlopParameters_PricingRule _internal_feasibility_rule() const;
  void _internal_set_feasibility_rule(::operations_research::glop::GlopParameters_PricingRule value);
  public:

  // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
  bool has_optimization_rule() const;
  private:
  bool _internal_has_optimization_rule() const;
  public:
  void clear_optimization_rule();
  ::operations_research::glop::GlopParameters_PricingRule optimization_rule() const;
  void set_optimization_rule(::operations_research::glop::GlopParameters_PricingRule value);
  private:
  ::operations_research::glop::GlopParameters_PricingRule _internal_optimization_rule() const;
  void _internal_set_optimization_rule(::operations_research::glop::GlopParameters_PricingRule value);
  public:

  // optional double refactorization_threshold = 6 [default = 1e-09];
  bool has_refactorization_threshold() const;
  private:
  bool _internal_has_refactorization_threshold() const;
  public:
  void clear_refactorization_threshold();
  double refactorization_threshold() const;
  void set_refactorization_threshold(double value);
  private:
  double _internal_refactorization_threshold() const;
  void _internal_set_refactorization_threshold(double value);
  public:

  // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
  bool has_recompute_reduced_costs_threshold() const;
  private:
  bool _internal_has_recompute_reduced_costs_threshold() const;
  public:
  void clear_recompute_reduced_costs_threshold();
  double recompute_reduced_costs_threshold() const;
  void set_recompute_reduced_costs_threshold(double value);
  private:
  double _internal_recompute_reduced_costs_threshold() const;
  void _internal_set_recompute_reduced_costs_threshold(double value);
  public:

  // optional double recompute_edges_norm_threshold = 9 [default = 100];
  bool has_recompute_edges_norm_threshold() const;
  private:
  bool _internal_has_recompute_edges_norm_threshold() const;
  public:
  void clear_recompute_edges_norm_threshold();
  double recompute_edges_norm_threshold() const;
  void set_recompute_edges_norm_threshold(double value);
  private:
  double _internal_recompute_edges_norm_threshold() const;
  void _internal_set_recompute_edges_norm_threshold(double value);
  public:

  // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
  bool has_primal_feasibility_tolerance() const;
  private:
  bool _internal_has_primal_feasibility_tolerance() const;
  public:
  void clear_primal_feasibility_tolerance();
  double primal_feasibility_tolerance() const;
  void set_primal_feasibility_tolerance(double value);
  private:
  double _internal_primal_feasibility_tolerance() const;
  void _internal_set_primal_feasibility_tolerance(double value);
  public:

  // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
  bool has_dual_feasibility_tolerance() const;
  private:
  bool _internal_has_dual_feasibility_tolerance() const;
  public:
  void clear_dual_feasibility_tolerance();
  double dual_feasibility_tolerance() const;
  void set_dual_feasibility_tolerance(double value);
  private:
  double _internal_dual_feasibility_tolerance() const;
  void _internal_set_dual_feasibility_tolerance(double value);
  public:

  // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
  bool has_ratio_test_zero_threshold() const;
  private:
  bool _internal_has_ratio_test_zero_threshold() const;
  public:
  void clear_ratio_test_zero_threshold();
  double ratio_test_zero_threshold() const;
  void set_ratio_test_zero_threshold(double value);
  private:
  double _internal_ratio_test_zero_threshold() const;
  void _internal_set_ratio_test_zero_threshold(double value);
  public:

  // optional double harris_tolerance_ratio = 13 [default = 0.5];
  bool has_harris_tolerance_ratio() const;
  private:
  bool _internal_has_harris_tolerance_ratio() const;
  public:
  void clear_harris_tolerance_ratio();
  double harris_tolerance_ratio() const;
  void set_harris_tolerance_ratio(double value);
  private:
  double _internal_harris_tolerance_ratio() const;
  void _internal_set_harris_tolerance_ratio(double value);
  public:

  // optional double small_pivot_threshold = 14 [default = 1e-06];
  bool has_small_pivot_threshold() const;
  private:
  bool _internal_has_small_pivot_threshold() const;
  public:
  void clear_small_pivot_threshold();
  double small_pivot_threshold() const;
  void set_small_pivot_threshold(double value);
  private:
  double _internal_small_pivot_threshold() const;
  void _internal_set_small_pivot_threshold(double value);
  public:

  // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
  bool has_minimum_acceptable_pivot() const;
  private:
  bool _internal_has_minimum_acceptable_pivot() const;
  public:
  void clear_minimum_acceptable_pivot();
  double minimum_acceptable_pivot() const;
  void set_minimum_acceptable_pivot(double value);
  private:
  double _internal_minimum_acceptable_pivot() const;
  void _internal_set_minimum_acceptable_pivot(double value);
  public:

  // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
  bool has_initial_basis() const;
  private:
  bool _internal_has_initial_basis() const;
  public:
  void clear_initial_basis();
  ::operations_research::glop::GlopParameters_InitialBasisHeuristic initial_basis() const;
  void set_initial_basis(::operations_research::glop::GlopParameters_InitialBasisHeuristic value);
  private:
  ::operations_research::glop::GlopParameters_InitialBasisHeuristic _internal_initial_basis() const;
  void _internal_set_initial_basis(::operations_research::glop::GlopParameters_InitialBasisHeuristic value);
  public:

  // optional int32 basis_refactorization_period = 19 [default = 64];
  bool has_basis_refactorization_period() const;
  private:
  bool _internal_has_basis_refactorization_period() const;
  public:
  void clear_basis_refactorization_period();
  ::PROTOBUF_NAMESPACE_ID::int32 basis_refactorization_period() const;
  void set_basis_refactorization_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_basis_refactorization_period() const;
  void _internal_set_basis_refactorization_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double dualizer_threshold = 21 [default = 1.5];
  bool has_dualizer_threshold() const;
  private:
  bool _internal_has_dualizer_threshold() const;
  public:
  void clear_dualizer_threshold();
  double dualizer_threshold() const;
  void set_dualizer_threshold(double value);
  private:
  double _internal_dualizer_threshold() const;
  void _internal_set_dualizer_threshold(double value);
  public:

  // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
  bool has_solution_feasibility_tolerance() const;
  private:
  bool _internal_has_solution_feasibility_tolerance() const;
  public:
  void clear_solution_feasibility_tolerance();
  double solution_feasibility_tolerance() const;
  void set_solution_feasibility_tolerance(double value);
  private:
  double _internal_solution_feasibility_tolerance() const;
  void _internal_set_solution_feasibility_tolerance(double value);
  public:

  // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
  bool has_solve_dual_problem() const;
  private:
  bool _internal_has_solve_dual_problem() const;
  public:
  void clear_solve_dual_problem();
  ::operations_research::glop::GlopParameters_SolverBehavior solve_dual_problem() const;
  void set_solve_dual_problem(::operations_research::glop::GlopParameters_SolverBehavior value);
  private:
  ::operations_research::glop::GlopParameters_SolverBehavior _internal_solve_dual_problem() const;
  void _internal_set_solve_dual_problem(::operations_research::glop::GlopParameters_SolverBehavior value);
  public:

  // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
  bool has_markowitz_zlatev_parameter() const;
  private:
  bool _internal_has_markowitz_zlatev_parameter() const;
  public:
  void clear_markowitz_zlatev_parameter();
  ::PROTOBUF_NAMESPACE_ID::int32 markowitz_zlatev_parameter() const;
  void set_markowitz_zlatev_parameter(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_markowitz_zlatev_parameter() const;
  void _internal_set_markowitz_zlatev_parameter(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
  bool has_lu_factorization_pivot_threshold() const;
  private:
  bool _internal_has_lu_factorization_pivot_threshold() const;
  public:
  void clear_lu_factorization_pivot_threshold();
  double lu_factorization_pivot_threshold() const;
  void set_lu_factorization_pivot_threshold(double value);
  private:
  double _internal_lu_factorization_pivot_threshold() const;
  void _internal_set_lu_factorization_pivot_threshold(double value);
  public:

  // optional double max_time_in_seconds = 26 [default = inf];
  bool has_max_time_in_seconds() const;
  private:
  bool _internal_has_max_time_in_seconds() const;
  public:
  void clear_max_time_in_seconds();
  double max_time_in_seconds() const;
  void set_max_time_in_seconds(double value);
  private:
  double _internal_max_time_in_seconds() const;
  void _internal_set_max_time_in_seconds(double value);
  public:

  // optional int64 max_number_of_iterations = 27 [default = -1];
  bool has_max_number_of_iterations() const;
  private:
  bool _internal_has_max_number_of_iterations() const;
  public:
  void clear_max_number_of_iterations();
  ::PROTOBUF_NAMESPACE_ID::int64 max_number_of_iterations() const;
  void set_max_number_of_iterations(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_number_of_iterations() const;
  void _internal_set_max_number_of_iterations(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
  bool has_markowitz_singularity_threshold() const;
  private:
  bool _internal_has_markowitz_singularity_threshold() const;
  public:
  void clear_markowitz_singularity_threshold();
  double markowitz_singularity_threshold() const;
  void set_markowitz_singularity_threshold(double value);
  private:
  double _internal_markowitz_singularity_threshold() const;
  void _internal_set_markowitz_singularity_threshold(double value);
  public:

  // optional bool use_scaling = 16 [default = true];
  bool has_use_scaling() const;
  private:
  bool _internal_has_use_scaling() const;
  public:
  void clear_use_scaling();
  bool use_scaling() const;
  void set_use_scaling(bool value);
  private:
  bool _internal_use_scaling() const;
  void _internal_set_use_scaling(bool value);
  public:

  // optional bool use_transposed_matrix = 18 [default = true];
  bool has_use_transposed_matrix() const;
  private:
  bool _internal_has_use_transposed_matrix() const;
  public:
  void clear_use_transposed_matrix();
  bool use_transposed_matrix() const;
  void set_use_transposed_matrix(bool value);
  private:
  bool _internal_use_transposed_matrix() const;
  void _internal_set_use_transposed_matrix(bool value);
  public:

  // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
  bool has_dynamically_adjust_refactorization_period() const;
  private:
  bool _internal_has_dynamically_adjust_refactorization_period() const;
  public:
  void clear_dynamically_adjust_refactorization_period();
  bool dynamically_adjust_refactorization_period() const;
  void set_dynamically_adjust_refactorization_period(bool value);
  private:
  bool _internal_dynamically_adjust_refactorization_period() const;
  void _internal_set_dynamically_adjust_refactorization_period(bool value);
  public:

  // optional bool provide_strong_optimal_guarantee = 24 [default = true];
  bool has_provide_strong_optimal_guarantee() const;
  private:
  bool _internal_has_provide_strong_optimal_guarantee() const;
  public:
  void clear_provide_strong_optimal_guarantee();
  bool provide_strong_optimal_guarantee() const;
  void set_provide_strong_optimal_guarantee(bool value);
  private:
  bool _internal_provide_strong_optimal_guarantee() const;
  void _internal_set_provide_strong_optimal_guarantee(bool value);
  public:

  // optional int32 devex_weights_reset_period = 33 [default = 150];
  bool has_devex_weights_reset_period() const;
  private:
  bool _internal_has_devex_weights_reset_period() const;
  public:
  void clear_devex_weights_reset_period();
  ::PROTOBUF_NAMESPACE_ID::int32 devex_weights_reset_period() const;
  void set_devex_weights_reset_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_devex_weights_reset_period() const;
  void _internal_set_devex_weights_reset_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
  bool has_dual_small_pivot_threshold() const;
  private:
  bool _internal_has_dual_small_pivot_threshold() const;
  public:
  void clear_dual_small_pivot_threshold();
  double dual_small_pivot_threshold() const;
  void set_dual_small_pivot_threshold(double value);
  private:
  double _internal_dual_small_pivot_threshold() const;
  void _internal_set_dual_small_pivot_threshold(double value);
  public:

  // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
  bool has_preprocessor_zero_tolerance() const;
  private:
  bool _internal_has_preprocessor_zero_tolerance() const;
  public:
  void clear_preprocessor_zero_tolerance();
  double preprocessor_zero_tolerance() const;
  void set_preprocessor_zero_tolerance(double value);
  private:
  double _internal_preprocessor_zero_tolerance() const;
  void _internal_set_preprocessor_zero_tolerance(double value);
  public:

  // optional double objective_lower_limit = 40 [default = -inf];
  bool has_objective_lower_limit() const;
  private:
  bool _internal_has_objective_lower_limit() const;
  public:
  void clear_objective_lower_limit();
  double objective_lower_limit() const;
  void set_objective_lower_limit(double value);
  private:
  double _internal_objective_lower_limit() const;
  void _internal_set_objective_lower_limit(double value);
  public:

  // optional double objective_upper_limit = 41 [default = inf];
  bool has_objective_upper_limit() const;
  private:
  bool _internal_has_objective_upper_limit() const;
  public:
  void clear_objective_upper_limit();
  double objective_upper_limit() const;
  void set_objective_upper_limit(double value);
  private:
  double _internal_objective_upper_limit() const;
  void _internal_set_objective_upper_limit(double value);
  public:

  // optional bool change_status_to_imprecise = 58 [default = true];
  bool has_change_status_to_imprecise() const;
  private:
  bool _internal_has_change_status_to_imprecise() const;
  public:
  void clear_change_status_to_imprecise();
  bool change_status_to_imprecise() const;
  void set_change_status_to_imprecise(bool value);
  private:
  bool _internal_change_status_to_imprecise() const;
  void _internal_set_change_status_to_imprecise(bool value);
  public:

  // optional bool use_preprocessing = 34 [default = true];
  bool has_use_preprocessing() const;
  private:
  bool _internal_has_use_preprocessing() const;
  public:
  void clear_use_preprocessing();
  bool use_preprocessing() const;
  void set_use_preprocessing(bool value);
  private:
  bool _internal_use_preprocessing() const;
  void _internal_set_use_preprocessing(bool value);
  public:

  // optional bool use_middle_product_form_update = 35 [default = true];
  bool has_use_middle_product_form_update() const;
  private:
  bool _internal_has_use_middle_product_form_update() const;
  public:
  void clear_use_middle_product_form_update();
  bool use_middle_product_form_update() const;
  void set_use_middle_product_form_update(bool value);
  private:
  bool _internal_use_middle_product_form_update() const;
  void _internal_set_use_middle_product_form_update(bool value);
  public:

  // optional bool initialize_devex_with_column_norms = 36 [default = true];
  bool has_initialize_devex_with_column_norms() const;
  private:
  bool _internal_has_initialize_devex_with_column_norms() const;
  public:
  void clear_initialize_devex_with_column_norms();
  bool initialize_devex_with_column_norms() const;
  void set_initialize_devex_with_column_norms(bool value);
  private:
  bool _internal_initialize_devex_with_column_norms() const;
  void _internal_set_initialize_devex_with_column_norms(bool value);
  public:

  // optional int32 random_seed = 43 [default = 1];
  bool has_random_seed() const;
  private:
  bool _internal_has_random_seed() const;
  public:
  void clear_random_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 random_seed() const;
  void set_random_seed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_random_seed() const;
  void _internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double degenerate_ministep_factor = 42 [default = 0.01];
  bool has_degenerate_ministep_factor() const;
  private:
  bool _internal_has_degenerate_ministep_factor() const;
  public:
  void clear_degenerate_ministep_factor();
  double degenerate_ministep_factor() const;
  void set_degenerate_ministep_factor(double value);
  private:
  double _internal_degenerate_ministep_factor() const;
  void _internal_set_degenerate_ministep_factor(double value);
  public:

  // optional double max_deterministic_time = 45 [default = inf];
  bool has_max_deterministic_time() const;
  private:
  bool _internal_has_max_deterministic_time() const;
  public:
  void clear_max_deterministic_time();
  double max_deterministic_time() const;
  void set_max_deterministic_time(double value);
  private:
  double _internal_max_deterministic_time() const;
  void _internal_set_max_deterministic_time(double value);
  public:

  // optional int32 num_omp_threads = 44 [default = 1];
  bool has_num_omp_threads() const;
  private:
  bool _internal_has_num_omp_threads() const;
  public:
  void clear_num_omp_threads();
  ::PROTOBUF_NAMESPACE_ID::int32 num_omp_threads() const;
  void set_num_omp_threads(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_omp_threads() const;
  void _internal_set_num_omp_threads(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
  bool has_exploit_singleton_column_in_initial_basis() const;
  private:
  bool _internal_has_exploit_singleton_column_in_initial_basis() const;
  public:
  void clear_exploit_singleton_column_in_initial_basis();
  bool exploit_singleton_column_in_initial_basis() const;
  void set_exploit_singleton_column_in_initial_basis(bool value);
  private:
  bool _internal_exploit_singleton_column_in_initial_basis() const;
  void _internal_set_exploit_singleton_column_in_initial_basis(bool value);
  public:

  // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
  bool has_use_dedicated_dual_feasibility_algorithm() const;
  private:
  bool _internal_has_use_dedicated_dual_feasibility_algorithm() const;
  public:
  void clear_use_dedicated_dual_feasibility_algorithm();
  bool use_dedicated_dual_feasibility_algorithm() const;
  void set_use_dedicated_dual_feasibility_algorithm(bool value);
  private:
  bool _internal_use_dedicated_dual_feasibility_algorithm() const;
  void _internal_set_use_dedicated_dual_feasibility_algorithm(bool value);
  public:

  // optional double drop_tolerance = 52 [default = 1e-14];
  bool has_drop_tolerance() const;
  private:
  bool _internal_has_drop_tolerance() const;
  public:
  void clear_drop_tolerance();
  double drop_tolerance() const;
  void set_drop_tolerance(double value);
  private:
  double _internal_drop_tolerance() const;
  void _internal_set_drop_tolerance(double value);
  public:

  // optional double relative_cost_perturbation = 54 [default = 1e-05];
  bool has_relative_cost_perturbation() const;
  private:
  bool _internal_has_relative_cost_perturbation() const;
  public:
  void clear_relative_cost_perturbation();
  double relative_cost_perturbation() const;
  void set_relative_cost_perturbation(double value);
  private:
  double _internal_relative_cost_perturbation() const;
  void _internal_set_relative_cost_perturbation(double value);
  public:

  // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
  bool has_relative_max_cost_perturbation() const;
  private:
  bool _internal_has_relative_max_cost_perturbation() const;
  public:
  void clear_relative_max_cost_perturbation();
  double relative_max_cost_perturbation() const;
  void set_relative_max_cost_perturbation(double value);
  private:
  double _internal_relative_max_cost_perturbation() const;
  void _internal_set_relative_max_cost_perturbation(double value);
  public:

  // optional double max_number_of_reoptimizations = 56 [default = 40];
  bool has_max_number_of_reoptimizations() const;
  private:
  bool _internal_has_max_number_of_reoptimizations() const;
  public:
  void clear_max_number_of_reoptimizations();
  double max_number_of_reoptimizations() const;
  void set_max_number_of_reoptimizations(double value);
  private:
  double _internal_max_number_of_reoptimizations() const;
  void _internal_set_max_number_of_reoptimizations(double value);
  public:

  // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
  bool has_scaling_method() const;
  private:
  bool _internal_has_scaling_method() const;
  public:
  void clear_scaling_method();
  ::operations_research::glop::GlopParameters_ScalingAlgorithm scaling_method() const;
  void set_scaling_method(::operations_research::glop::GlopParameters_ScalingAlgorithm value);
  private:
  ::operations_research::glop::GlopParameters_ScalingAlgorithm _internal_scaling_method() const;
  void _internal_set_scaling_method(::operations_research::glop::GlopParameters_ScalingAlgorithm value);
  public:

  // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
  bool has_cost_scaling() const;
  private:
  bool _internal_has_cost_scaling() const;
  public:
  void clear_cost_scaling();
  ::operations_research::glop::GlopParameters_CostScalingAlgorithm cost_scaling() const;
  void set_cost_scaling(::operations_research::glop::GlopParameters_CostScalingAlgorithm value);
  private:
  ::operations_research::glop::GlopParameters_CostScalingAlgorithm _internal_cost_scaling() const;
  void _internal_set_cost_scaling(::operations_research::glop::GlopParameters_CostScalingAlgorithm value);
  public:

  // optional double initial_condition_number_threshold = 59 [default = 1e+50];
  bool has_initial_condition_number_threshold() const;
  private:
  bool _internal_has_initial_condition_number_threshold() const;
  public:
  void clear_initial_condition_number_threshold();
  double initial_condition_number_threshold() const;
  void set_initial_condition_number_threshold(double value);
  private:
  double _internal_initial_condition_number_threshold() const;
  void _internal_set_initial_condition_number_threshold(double value);
  public:

  // @@protoc_insertion_point(class_scope:operations_research.glop.GlopParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_dual_simplex_;
  bool allow_simplex_algorithm_change_;
  bool perturb_costs_in_dual_simplex_;
  bool log_search_progress_;
  int feasibility_rule_;
  int optimization_rule_;
  double refactorization_threshold_;
  double recompute_reduced_costs_threshold_;
  double recompute_edges_norm_threshold_;
  double primal_feasibility_tolerance_;
  double dual_feasibility_tolerance_;
  double ratio_test_zero_threshold_;
  double harris_tolerance_ratio_;
  double small_pivot_threshold_;
  double minimum_acceptable_pivot_;
  int initial_basis_;
  ::PROTOBUF_NAMESPACE_ID::int32 basis_refactorization_period_;
  double dualizer_threshold_;
  double solution_feasibility_tolerance_;
  int solve_dual_problem_;
  ::PROTOBUF_NAMESPACE_ID::int32 markowitz_zlatev_parameter_;
  double lu_factorization_pivot_threshold_;
  double max_time_in_seconds_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_number_of_iterations_;
  double markowitz_singularity_threshold_;
  bool use_scaling_;
  bool use_transposed_matrix_;
  bool dynamically_adjust_refactorization_period_;
  bool provide_strong_optimal_guarantee_;
  ::PROTOBUF_NAMESPACE_ID::int32 devex_weights_reset_period_;
  double dual_small_pivot_threshold_;
  double preprocessor_zero_tolerance_;
  double objective_lower_limit_;
  double objective_upper_limit_;
  bool change_status_to_imprecise_;
  bool use_preprocessing_;
  bool use_middle_product_form_update_;
  bool initialize_devex_with_column_norms_;
  ::PROTOBUF_NAMESPACE_ID::int32 random_seed_;
  double degenerate_ministep_factor_;
  double max_deterministic_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_omp_threads_;
  bool exploit_singleton_column_in_initial_basis_;
  bool use_dedicated_dual_feasibility_algorithm_;
  double drop_tolerance_;
  double relative_cost_perturbation_;
  double relative_max_cost_perturbation_;
  double max_number_of_reoptimizations_;
  int scaling_method_;
  int cost_scaling_;
  double initial_condition_number_threshold_;
  friend struct ::TableStruct_ortools_2fglop_2fparameters_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GlopParameters

// optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
inline bool GlopParameters::_internal_has_scaling_method() const {
  bool value = (_has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool GlopParameters::has_scaling_method() const {
  return _internal_has_scaling_method();
}
inline void GlopParameters::clear_scaling_method() {
  scaling_method_ = 1;
  _has_bits_[1] &= ~0x00010000u;
}
inline ::operations_research::glop::GlopParameters_ScalingAlgorithm GlopParameters::_internal_scaling_method() const {
  return static_cast< ::operations_research::glop::GlopParameters_ScalingAlgorithm >(scaling_method_);
}
inline ::operations_research::glop::GlopParameters_ScalingAlgorithm GlopParameters::scaling_method() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.scaling_method)
  return _internal_scaling_method();
}
inline void GlopParameters::_internal_set_scaling_method(::operations_research::glop::GlopParameters_ScalingAlgorithm value) {
  assert(::operations_research::glop::GlopParameters_ScalingAlgorithm_IsValid(value));
  _has_bits_[1] |= 0x00010000u;
  scaling_method_ = value;
}
inline void GlopParameters::set_scaling_method(::operations_research::glop::GlopParameters_ScalingAlgorithm value) {
  _internal_set_scaling_method(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.scaling_method)
}

// optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
inline bool GlopParameters::_internal_has_feasibility_rule() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GlopParameters::has_feasibility_rule() const {
  return _internal_has_feasibility_rule();
}
inline void GlopParameters::clear_feasibility_rule() {
  feasibility_rule_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::operations_research::glop::GlopParameters_PricingRule GlopParameters::_internal_feasibility_rule() const {
  return static_cast< ::operations_research::glop::GlopParameters_PricingRule >(feasibility_rule_);
}
inline ::operations_research::glop::GlopParameters_PricingRule GlopParameters::feasibility_rule() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.feasibility_rule)
  return _internal_feasibility_rule();
}
inline void GlopParameters::_internal_set_feasibility_rule(::operations_research::glop::GlopParameters_PricingRule value) {
  assert(::operations_research::glop::GlopParameters_PricingRule_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  feasibility_rule_ = value;
}
inline void GlopParameters::set_feasibility_rule(::operations_research::glop::GlopParameters_PricingRule value) {
  _internal_set_feasibility_rule(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.feasibility_rule)
}

// optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
inline bool GlopParameters::_internal_has_optimization_rule() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GlopParameters::has_optimization_rule() const {
  return _internal_has_optimization_rule();
}
inline void GlopParameters::clear_optimization_rule() {
  optimization_rule_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::operations_research::glop::GlopParameters_PricingRule GlopParameters::_internal_optimization_rule() const {
  return static_cast< ::operations_research::glop::GlopParameters_PricingRule >(optimization_rule_);
}
inline ::operations_research::glop::GlopParameters_PricingRule GlopParameters::optimization_rule() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.optimization_rule)
  return _internal_optimization_rule();
}
inline void GlopParameters::_internal_set_optimization_rule(::operations_research::glop::GlopParameters_PricingRule value) {
  assert(::operations_research::glop::GlopParameters_PricingRule_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  optimization_rule_ = value;
}
inline void GlopParameters::set_optimization_rule(::operations_research::glop::GlopParameters_PricingRule value) {
  _internal_set_optimization_rule(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.optimization_rule)
}

// optional double refactorization_threshold = 6 [default = 1e-09];
inline bool GlopParameters::_internal_has_refactorization_threshold() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GlopParameters::has_refactorization_threshold() const {
  return _internal_has_refactorization_threshold();
}
inline void GlopParameters::clear_refactorization_threshold() {
  refactorization_threshold_ = 1e-09;
  _has_bits_[0] &= ~0x00000040u;
}
inline double GlopParameters::_internal_refactorization_threshold() const {
  return refactorization_threshold_;
}
inline double GlopParameters::refactorization_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.refactorization_threshold)
  return _internal_refactorization_threshold();
}
inline void GlopParameters::_internal_set_refactorization_threshold(double value) {
  _has_bits_[0] |= 0x00000040u;
  refactorization_threshold_ = value;
}
inline void GlopParameters::set_refactorization_threshold(double value) {
  _internal_set_refactorization_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.refactorization_threshold)
}

// optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
inline bool GlopParameters::_internal_has_recompute_reduced_costs_threshold() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GlopParameters::has_recompute_reduced_costs_threshold() const {
  return _internal_has_recompute_reduced_costs_threshold();
}
inline void GlopParameters::clear_recompute_reduced_costs_threshold() {
  recompute_reduced_costs_threshold_ = 1e-08;
  _has_bits_[0] &= ~0x00000080u;
}
inline double GlopParameters::_internal_recompute_reduced_costs_threshold() const {
  return recompute_reduced_costs_threshold_;
}
inline double GlopParameters::recompute_reduced_costs_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.recompute_reduced_costs_threshold)
  return _internal_recompute_reduced_costs_threshold();
}
inline void GlopParameters::_internal_set_recompute_reduced_costs_threshold(double value) {
  _has_bits_[0] |= 0x00000080u;
  recompute_reduced_costs_threshold_ = value;
}
inline void GlopParameters::set_recompute_reduced_costs_threshold(double value) {
  _internal_set_recompute_reduced_costs_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.recompute_reduced_costs_threshold)
}

// optional double recompute_edges_norm_threshold = 9 [default = 100];
inline bool GlopParameters::_internal_has_recompute_edges_norm_threshold() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GlopParameters::has_recompute_edges_norm_threshold() const {
  return _internal_has_recompute_edges_norm_threshold();
}
inline void GlopParameters::clear_recompute_edges_norm_threshold() {
  recompute_edges_norm_threshold_ = 100;
  _has_bits_[0] &= ~0x00000100u;
}
inline double GlopParameters::_internal_recompute_edges_norm_threshold() const {
  return recompute_edges_norm_threshold_;
}
inline double GlopParameters::recompute_edges_norm_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.recompute_edges_norm_threshold)
  return _internal_recompute_edges_norm_threshold();
}
inline void GlopParameters::_internal_set_recompute_edges_norm_threshold(double value) {
  _has_bits_[0] |= 0x00000100u;
  recompute_edges_norm_threshold_ = value;
}
inline void GlopParameters::set_recompute_edges_norm_threshold(double value) {
  _internal_set_recompute_edges_norm_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.recompute_edges_norm_threshold)
}

// optional double primal_feasibility_tolerance = 10 [default = 1e-08];
inline bool GlopParameters::_internal_has_primal_feasibility_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GlopParameters::has_primal_feasibility_tolerance() const {
  return _internal_has_primal_feasibility_tolerance();
}
inline void GlopParameters::clear_primal_feasibility_tolerance() {
  primal_feasibility_tolerance_ = 1e-08;
  _has_bits_[0] &= ~0x00000200u;
}
inline double GlopParameters::_internal_primal_feasibility_tolerance() const {
  return primal_feasibility_tolerance_;
}
inline double GlopParameters::primal_feasibility_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.primal_feasibility_tolerance)
  return _internal_primal_feasibility_tolerance();
}
inline void GlopParameters::_internal_set_primal_feasibility_tolerance(double value) {
  _has_bits_[0] |= 0x00000200u;
  primal_feasibility_tolerance_ = value;
}
inline void GlopParameters::set_primal_feasibility_tolerance(double value) {
  _internal_set_primal_feasibility_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.primal_feasibility_tolerance)
}

// optional double dual_feasibility_tolerance = 11 [default = 1e-08];
inline bool GlopParameters::_internal_has_dual_feasibility_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool GlopParameters::has_dual_feasibility_tolerance() const {
  return _internal_has_dual_feasibility_tolerance();
}
inline void GlopParameters::clear_dual_feasibility_tolerance() {
  dual_feasibility_tolerance_ = 1e-08;
  _has_bits_[0] &= ~0x00000400u;
}
inline double GlopParameters::_internal_dual_feasibility_tolerance() const {
  return dual_feasibility_tolerance_;
}
inline double GlopParameters::dual_feasibility_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dual_feasibility_tolerance)
  return _internal_dual_feasibility_tolerance();
}
inline void GlopParameters::_internal_set_dual_feasibility_tolerance(double value) {
  _has_bits_[0] |= 0x00000400u;
  dual_feasibility_tolerance_ = value;
}
inline void GlopParameters::set_dual_feasibility_tolerance(double value) {
  _internal_set_dual_feasibility_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dual_feasibility_tolerance)
}

// optional double ratio_test_zero_threshold = 12 [default = 1e-09];
inline bool GlopParameters::_internal_has_ratio_test_zero_threshold() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool GlopParameters::has_ratio_test_zero_threshold() const {
  return _internal_has_ratio_test_zero_threshold();
}
inline void GlopParameters::clear_ratio_test_zero_threshold() {
  ratio_test_zero_threshold_ = 1e-09;
  _has_bits_[0] &= ~0x00000800u;
}
inline double GlopParameters::_internal_ratio_test_zero_threshold() const {
  return ratio_test_zero_threshold_;
}
inline double GlopParameters::ratio_test_zero_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.ratio_test_zero_threshold)
  return _internal_ratio_test_zero_threshold();
}
inline void GlopParameters::_internal_set_ratio_test_zero_threshold(double value) {
  _has_bits_[0] |= 0x00000800u;
  ratio_test_zero_threshold_ = value;
}
inline void GlopParameters::set_ratio_test_zero_threshold(double value) {
  _internal_set_ratio_test_zero_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.ratio_test_zero_threshold)
}

// optional double harris_tolerance_ratio = 13 [default = 0.5];
inline bool GlopParameters::_internal_has_harris_tolerance_ratio() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool GlopParameters::has_harris_tolerance_ratio() const {
  return _internal_has_harris_tolerance_ratio();
}
inline void GlopParameters::clear_harris_tolerance_ratio() {
  harris_tolerance_ratio_ = 0.5;
  _has_bits_[0] &= ~0x00001000u;
}
inline double GlopParameters::_internal_harris_tolerance_ratio() const {
  return harris_tolerance_ratio_;
}
inline double GlopParameters::harris_tolerance_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.harris_tolerance_ratio)
  return _internal_harris_tolerance_ratio();
}
inline void GlopParameters::_internal_set_harris_tolerance_ratio(double value) {
  _has_bits_[0] |= 0x00001000u;
  harris_tolerance_ratio_ = value;
}
inline void GlopParameters::set_harris_tolerance_ratio(double value) {
  _internal_set_harris_tolerance_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.harris_tolerance_ratio)
}

// optional double small_pivot_threshold = 14 [default = 1e-06];
inline bool GlopParameters::_internal_has_small_pivot_threshold() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool GlopParameters::has_small_pivot_threshold() const {
  return _internal_has_small_pivot_threshold();
}
inline void GlopParameters::clear_small_pivot_threshold() {
  small_pivot_threshold_ = 1e-06;
  _has_bits_[0] &= ~0x00002000u;
}
inline double GlopParameters::_internal_small_pivot_threshold() const {
  return small_pivot_threshold_;
}
inline double GlopParameters::small_pivot_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.small_pivot_threshold)
  return _internal_small_pivot_threshold();
}
inline void GlopParameters::_internal_set_small_pivot_threshold(double value) {
  _has_bits_[0] |= 0x00002000u;
  small_pivot_threshold_ = value;
}
inline void GlopParameters::set_small_pivot_threshold(double value) {
  _internal_set_small_pivot_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.small_pivot_threshold)
}

// optional double minimum_acceptable_pivot = 15 [default = 1e-06];
inline bool GlopParameters::_internal_has_minimum_acceptable_pivot() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool GlopParameters::has_minimum_acceptable_pivot() const {
  return _internal_has_minimum_acceptable_pivot();
}
inline void GlopParameters::clear_minimum_acceptable_pivot() {
  minimum_acceptable_pivot_ = 1e-06;
  _has_bits_[0] &= ~0x00004000u;
}
inline double GlopParameters::_internal_minimum_acceptable_pivot() const {
  return minimum_acceptable_pivot_;
}
inline double GlopParameters::minimum_acceptable_pivot() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.minimum_acceptable_pivot)
  return _internal_minimum_acceptable_pivot();
}
inline void GlopParameters::_internal_set_minimum_acceptable_pivot(double value) {
  _has_bits_[0] |= 0x00004000u;
  minimum_acceptable_pivot_ = value;
}
inline void GlopParameters::set_minimum_acceptable_pivot(double value) {
  _internal_set_minimum_acceptable_pivot(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.minimum_acceptable_pivot)
}

// optional double drop_tolerance = 52 [default = 1e-14];
inline bool GlopParameters::_internal_has_drop_tolerance() const {
  bool value = (_has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool GlopParameters::has_drop_tolerance() const {
  return _internal_has_drop_tolerance();
}
inline void GlopParameters::clear_drop_tolerance() {
  drop_tolerance_ = 1e-14;
  _has_bits_[1] &= ~0x00001000u;
}
inline double GlopParameters::_internal_drop_tolerance() const {
  return drop_tolerance_;
}
inline double GlopParameters::drop_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.drop_tolerance)
  return _internal_drop_tolerance();
}
inline void GlopParameters::_internal_set_drop_tolerance(double value) {
  _has_bits_[1] |= 0x00001000u;
  drop_tolerance_ = value;
}
inline void GlopParameters::set_drop_tolerance(double value) {
  _internal_set_drop_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.drop_tolerance)
}

// optional bool use_scaling = 16 [default = true];
inline bool GlopParameters::_internal_has_use_scaling() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool GlopParameters::has_use_scaling() const {
  return _internal_has_use_scaling();
}
inline void GlopParameters::clear_use_scaling() {
  use_scaling_ = true;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool GlopParameters::_internal_use_scaling() const {
  return use_scaling_;
}
inline bool GlopParameters::use_scaling() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_scaling)
  return _internal_use_scaling();
}
inline void GlopParameters::_internal_set_use_scaling(bool value) {
  _has_bits_[0] |= 0x02000000u;
  use_scaling_ = value;
}
inline void GlopParameters::set_use_scaling(bool value) {
  _internal_set_use_scaling(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_scaling)
}

// optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
inline bool GlopParameters::_internal_has_cost_scaling() const {
  bool value = (_has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool GlopParameters::has_cost_scaling() const {
  return _internal_has_cost_scaling();
}
inline void GlopParameters::clear_cost_scaling() {
  cost_scaling_ = 1;
  _has_bits_[1] &= ~0x00020000u;
}
inline ::operations_research::glop::GlopParameters_CostScalingAlgorithm GlopParameters::_internal_cost_scaling() const {
  return static_cast< ::operations_research::glop::GlopParameters_CostScalingAlgorithm >(cost_scaling_);
}
inline ::operations_research::glop::GlopParameters_CostScalingAlgorithm GlopParameters::cost_scaling() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.cost_scaling)
  return _internal_cost_scaling();
}
inline void GlopParameters::_internal_set_cost_scaling(::operations_research::glop::GlopParameters_CostScalingAlgorithm value) {
  assert(::operations_research::glop::GlopParameters_CostScalingAlgorithm_IsValid(value));
  _has_bits_[1] |= 0x00020000u;
  cost_scaling_ = value;
}
inline void GlopParameters::set_cost_scaling(::operations_research::glop::GlopParameters_CostScalingAlgorithm value) {
  _internal_set_cost_scaling(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.cost_scaling)
}

// optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
inline bool GlopParameters::_internal_has_initial_basis() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool GlopParameters::has_initial_basis() const {
  return _internal_has_initial_basis();
}
inline void GlopParameters::clear_initial_basis() {
  initial_basis_ = 2;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::operations_research::glop::GlopParameters_InitialBasisHeuristic GlopParameters::_internal_initial_basis() const {
  return static_cast< ::operations_research::glop::GlopParameters_InitialBasisHeuristic >(initial_basis_);
}
inline ::operations_research::glop::GlopParameters_InitialBasisHeuristic GlopParameters::initial_basis() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.initial_basis)
  return _internal_initial_basis();
}
inline void GlopParameters::_internal_set_initial_basis(::operations_research::glop::GlopParameters_InitialBasisHeuristic value) {
  assert(::operations_research::glop::GlopParameters_InitialBasisHeuristic_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  initial_basis_ = value;
}
inline void GlopParameters::set_initial_basis(::operations_research::glop::GlopParameters_InitialBasisHeuristic value) {
  _internal_set_initial_basis(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.initial_basis)
}

// optional bool use_transposed_matrix = 18 [default = true];
inline bool GlopParameters::_internal_has_use_transposed_matrix() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool GlopParameters::has_use_transposed_matrix() const {
  return _internal_has_use_transposed_matrix();
}
inline void GlopParameters::clear_use_transposed_matrix() {
  use_transposed_matrix_ = true;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool GlopParameters::_internal_use_transposed_matrix() const {
  return use_transposed_matrix_;
}
inline bool GlopParameters::use_transposed_matrix() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_transposed_matrix)
  return _internal_use_transposed_matrix();
}
inline void GlopParameters::_internal_set_use_transposed_matrix(bool value) {
  _has_bits_[0] |= 0x04000000u;
  use_transposed_matrix_ = value;
}
inline void GlopParameters::set_use_transposed_matrix(bool value) {
  _internal_set_use_transposed_matrix(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_transposed_matrix)
}

// optional int32 basis_refactorization_period = 19 [default = 64];
inline bool GlopParameters::_internal_has_basis_refactorization_period() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool GlopParameters::has_basis_refactorization_period() const {
  return _internal_has_basis_refactorization_period();
}
inline void GlopParameters::clear_basis_refactorization_period() {
  basis_refactorization_period_ = 64;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::_internal_basis_refactorization_period() const {
  return basis_refactorization_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::basis_refactorization_period() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.basis_refactorization_period)
  return _internal_basis_refactorization_period();
}
inline void GlopParameters::_internal_set_basis_refactorization_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00010000u;
  basis_refactorization_period_ = value;
}
inline void GlopParameters::set_basis_refactorization_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_basis_refactorization_period(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.basis_refactorization_period)
}

// optional bool dynamically_adjust_refactorization_period = 63 [default = true];
inline bool GlopParameters::_internal_has_dynamically_adjust_refactorization_period() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool GlopParameters::has_dynamically_adjust_refactorization_period() const {
  return _internal_has_dynamically_adjust_refactorization_period();
}
inline void GlopParameters::clear_dynamically_adjust_refactorization_period() {
  dynamically_adjust_refactorization_period_ = true;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool GlopParameters::_internal_dynamically_adjust_refactorization_period() const {
  return dynamically_adjust_refactorization_period_;
}
inline bool GlopParameters::dynamically_adjust_refactorization_period() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dynamically_adjust_refactorization_period)
  return _internal_dynamically_adjust_refactorization_period();
}
inline void GlopParameters::_internal_set_dynamically_adjust_refactorization_period(bool value) {
  _has_bits_[0] |= 0x08000000u;
  dynamically_adjust_refactorization_period_ = value;
}
inline void GlopParameters::set_dynamically_adjust_refactorization_period(bool value) {
  _internal_set_dynamically_adjust_refactorization_period(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dynamically_adjust_refactorization_period)
}

// optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
inline bool GlopParameters::_internal_has_solve_dual_problem() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool GlopParameters::has_solve_dual_problem() const {
  return _internal_has_solve_dual_problem();
}
inline void GlopParameters::clear_solve_dual_problem() {
  solve_dual_problem_ = 2;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::operations_research::glop::GlopParameters_SolverBehavior GlopParameters::_internal_solve_dual_problem() const {
  return static_cast< ::operations_research::glop::GlopParameters_SolverBehavior >(solve_dual_problem_);
}
inline ::operations_research::glop::GlopParameters_SolverBehavior GlopParameters::solve_dual_problem() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.solve_dual_problem)
  return _internal_solve_dual_problem();
}
inline void GlopParameters::_internal_set_solve_dual_problem(::operations_research::glop::GlopParameters_SolverBehavior value) {
  assert(::operations_research::glop::GlopParameters_SolverBehavior_IsValid(value));
  _has_bits_[0] |= 0x00080000u;
  solve_dual_problem_ = value;
}
inline void GlopParameters::set_solve_dual_problem(::operations_research::glop::GlopParameters_SolverBehavior value) {
  _internal_set_solve_dual_problem(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.solve_dual_problem)
}

// optional double dualizer_threshold = 21 [default = 1.5];
inline bool GlopParameters::_internal_has_dualizer_threshold() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool GlopParameters::has_dualizer_threshold() const {
  return _internal_has_dualizer_threshold();
}
inline void GlopParameters::clear_dualizer_threshold() {
  dualizer_threshold_ = 1.5;
  _has_bits_[0] &= ~0x00020000u;
}
inline double GlopParameters::_internal_dualizer_threshold() const {
  return dualizer_threshold_;
}
inline double GlopParameters::dualizer_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dualizer_threshold)
  return _internal_dualizer_threshold();
}
inline void GlopParameters::_internal_set_dualizer_threshold(double value) {
  _has_bits_[0] |= 0x00020000u;
  dualizer_threshold_ = value;
}
inline void GlopParameters::set_dualizer_threshold(double value) {
  _internal_set_dualizer_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dualizer_threshold)
}

// optional double solution_feasibility_tolerance = 22 [default = 1e-06];
inline bool GlopParameters::_internal_has_solution_feasibility_tolerance() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool GlopParameters::has_solution_feasibility_tolerance() const {
  return _internal_has_solution_feasibility_tolerance();
}
inline void GlopParameters::clear_solution_feasibility_tolerance() {
  solution_feasibility_tolerance_ = 1e-06;
  _has_bits_[0] &= ~0x00040000u;
}
inline double GlopParameters::_internal_solution_feasibility_tolerance() const {
  return solution_feasibility_tolerance_;
}
inline double GlopParameters::solution_feasibility_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.solution_feasibility_tolerance)
  return _internal_solution_feasibility_tolerance();
}
inline void GlopParameters::_internal_set_solution_feasibility_tolerance(double value) {
  _has_bits_[0] |= 0x00040000u;
  solution_feasibility_tolerance_ = value;
}
inline void GlopParameters::set_solution_feasibility_tolerance(double value) {
  _internal_set_solution_feasibility_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.solution_feasibility_tolerance)
}

// optional bool provide_strong_optimal_guarantee = 24 [default = true];
inline bool GlopParameters::_internal_has_provide_strong_optimal_guarantee() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool GlopParameters::has_provide_strong_optimal_guarantee() const {
  return _internal_has_provide_strong_optimal_guarantee();
}
inline void GlopParameters::clear_provide_strong_optimal_guarantee() {
  provide_strong_optimal_guarantee_ = true;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool GlopParameters::_internal_provide_strong_optimal_guarantee() const {
  return provide_strong_optimal_guarantee_;
}
inline bool GlopParameters::provide_strong_optimal_guarantee() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.provide_strong_optimal_guarantee)
  return _internal_provide_strong_optimal_guarantee();
}
inline void GlopParameters::_internal_set_provide_strong_optimal_guarantee(bool value) {
  _has_bits_[0] |= 0x10000000u;
  provide_strong_optimal_guarantee_ = value;
}
inline void GlopParameters::set_provide_strong_optimal_guarantee(bool value) {
  _internal_set_provide_strong_optimal_guarantee(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.provide_strong_optimal_guarantee)
}

// optional bool change_status_to_imprecise = 58 [default = true];
inline bool GlopParameters::_internal_has_change_status_to_imprecise() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool GlopParameters::has_change_status_to_imprecise() const {
  return _internal_has_change_status_to_imprecise();
}
inline void GlopParameters::clear_change_status_to_imprecise() {
  change_status_to_imprecise_ = true;
  _has_bits_[1] &= ~0x00000004u;
}
inline bool GlopParameters::_internal_change_status_to_imprecise() const {
  return change_status_to_imprecise_;
}
inline bool GlopParameters::change_status_to_imprecise() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.change_status_to_imprecise)
  return _internal_change_status_to_imprecise();
}
inline void GlopParameters::_internal_set_change_status_to_imprecise(bool value) {
  _has_bits_[1] |= 0x00000004u;
  change_status_to_imprecise_ = value;
}
inline void GlopParameters::set_change_status_to_imprecise(bool value) {
  _internal_set_change_status_to_imprecise(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.change_status_to_imprecise)
}

// optional double max_number_of_reoptimizations = 56 [default = 40];
inline bool GlopParameters::_internal_has_max_number_of_reoptimizations() const {
  bool value = (_has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool GlopParameters::has_max_number_of_reoptimizations() const {
  return _internal_has_max_number_of_reoptimizations();
}
inline void GlopParameters::clear_max_number_of_reoptimizations() {
  max_number_of_reoptimizations_ = 40;
  _has_bits_[1] &= ~0x00008000u;
}
inline double GlopParameters::_internal_max_number_of_reoptimizations() const {
  return max_number_of_reoptimizations_;
}
inline double GlopParameters::max_number_of_reoptimizations() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_number_of_reoptimizations)
  return _internal_max_number_of_reoptimizations();
}
inline void GlopParameters::_internal_set_max_number_of_reoptimizations(double value) {
  _has_bits_[1] |= 0x00008000u;
  max_number_of_reoptimizations_ = value;
}
inline void GlopParameters::set_max_number_of_reoptimizations(double value) {
  _internal_set_max_number_of_reoptimizations(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_number_of_reoptimizations)
}

// optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
inline bool GlopParameters::_internal_has_lu_factorization_pivot_threshold() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool GlopParameters::has_lu_factorization_pivot_threshold() const {
  return _internal_has_lu_factorization_pivot_threshold();
}
inline void GlopParameters::clear_lu_factorization_pivot_threshold() {
  lu_factorization_pivot_threshold_ = 0.01;
  _has_bits_[0] &= ~0x00200000u;
}
inline double GlopParameters::_internal_lu_factorization_pivot_threshold() const {
  return lu_factorization_pivot_threshold_;
}
inline double GlopParameters::lu_factorization_pivot_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.lu_factorization_pivot_threshold)
  return _internal_lu_factorization_pivot_threshold();
}
inline void GlopParameters::_internal_set_lu_factorization_pivot_threshold(double value) {
  _has_bits_[0] |= 0x00200000u;
  lu_factorization_pivot_threshold_ = value;
}
inline void GlopParameters::set_lu_factorization_pivot_threshold(double value) {
  _internal_set_lu_factorization_pivot_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.lu_factorization_pivot_threshold)
}

// optional double max_time_in_seconds = 26 [default = inf];
inline bool GlopParameters::_internal_has_max_time_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool GlopParameters::has_max_time_in_seconds() const {
  return _internal_has_max_time_in_seconds();
}
inline void GlopParameters::clear_max_time_in_seconds() {
  max_time_in_seconds_ = std::numeric_limits<double>::infinity();
  _has_bits_[0] &= ~0x00400000u;
}
inline double GlopParameters::_internal_max_time_in_seconds() const {
  return max_time_in_seconds_;
}
inline double GlopParameters::max_time_in_seconds() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_time_in_seconds)
  return _internal_max_time_in_seconds();
}
inline void GlopParameters::_internal_set_max_time_in_seconds(double value) {
  _has_bits_[0] |= 0x00400000u;
  max_time_in_seconds_ = value;
}
inline void GlopParameters::set_max_time_in_seconds(double value) {
  _internal_set_max_time_in_seconds(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_time_in_seconds)
}

// optional double max_deterministic_time = 45 [default = inf];
inline bool GlopParameters::_internal_has_max_deterministic_time() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool GlopParameters::has_max_deterministic_time() const {
  return _internal_has_max_deterministic_time();
}
inline void GlopParameters::clear_max_deterministic_time() {
  max_deterministic_time_ = std::numeric_limits<double>::infinity();
  _has_bits_[1] &= ~0x00000100u;
}
inline double GlopParameters::_internal_max_deterministic_time() const {
  return max_deterministic_time_;
}
inline double GlopParameters::max_deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_deterministic_time)
  return _internal_max_deterministic_time();
}
inline void GlopParameters::_internal_set_max_deterministic_time(double value) {
  _has_bits_[1] |= 0x00000100u;
  max_deterministic_time_ = value;
}
inline void GlopParameters::set_max_deterministic_time(double value) {
  _internal_set_max_deterministic_time(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_deterministic_time)
}

// optional int64 max_number_of_iterations = 27 [default = -1];
inline bool GlopParameters::_internal_has_max_number_of_iterations() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool GlopParameters::has_max_number_of_iterations() const {
  return _internal_has_max_number_of_iterations();
}
inline void GlopParameters::clear_max_number_of_iterations() {
  max_number_of_iterations_ = int64_t{-1};
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GlopParameters::_internal_max_number_of_iterations() const {
  return max_number_of_iterations_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GlopParameters::max_number_of_iterations() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_number_of_iterations)
  return _internal_max_number_of_iterations();
}
inline void GlopParameters::_internal_set_max_number_of_iterations(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00800000u;
  max_number_of_iterations_ = value;
}
inline void GlopParameters::set_max_number_of_iterations(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_number_of_iterations(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_number_of_iterations)
}

// optional int32 markowitz_zlatev_parameter = 29 [default = 3];
inline bool GlopParameters::_internal_has_markowitz_zlatev_parameter() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool GlopParameters::has_markowitz_zlatev_parameter() const {
  return _internal_has_markowitz_zlatev_parameter();
}
inline void GlopParameters::clear_markowitz_zlatev_parameter() {
  markowitz_zlatev_parameter_ = 3;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::_internal_markowitz_zlatev_parameter() const {
  return markowitz_zlatev_parameter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::markowitz_zlatev_parameter() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.markowitz_zlatev_parameter)
  return _internal_markowitz_zlatev_parameter();
}
inline void GlopParameters::_internal_set_markowitz_zlatev_parameter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  markowitz_zlatev_parameter_ = value;
}
inline void GlopParameters::set_markowitz_zlatev_parameter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_markowitz_zlatev_parameter(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.markowitz_zlatev_parameter)
}

// optional double markowitz_singularity_threshold = 30 [default = 1e-15];
inline bool GlopParameters::_internal_has_markowitz_singularity_threshold() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool GlopParameters::has_markowitz_singularity_threshold() const {
  return _internal_has_markowitz_singularity_threshold();
}
inline void GlopParameters::clear_markowitz_singularity_threshold() {
  markowitz_singularity_threshold_ = 1e-15;
  _has_bits_[0] &= ~0x01000000u;
}
inline double GlopParameters::_internal_markowitz_singularity_threshold() const {
  return markowitz_singularity_threshold_;
}
inline double GlopParameters::markowitz_singularity_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.markowitz_singularity_threshold)
  return _internal_markowitz_singularity_threshold();
}
inline void GlopParameters::_internal_set_markowitz_singularity_threshold(double value) {
  _has_bits_[0] |= 0x01000000u;
  markowitz_singularity_threshold_ = value;
}
inline void GlopParameters::set_markowitz_singularity_threshold(double value) {
  _internal_set_markowitz_singularity_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.markowitz_singularity_threshold)
}

// optional bool use_dual_simplex = 31 [default = false];
inline bool GlopParameters::_internal_has_use_dual_simplex() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlopParameters::has_use_dual_simplex() const {
  return _internal_has_use_dual_simplex();
}
inline void GlopParameters::clear_use_dual_simplex() {
  use_dual_simplex_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool GlopParameters::_internal_use_dual_simplex() const {
  return use_dual_simplex_;
}
inline bool GlopParameters::use_dual_simplex() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_dual_simplex)
  return _internal_use_dual_simplex();
}
inline void GlopParameters::_internal_set_use_dual_simplex(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_dual_simplex_ = value;
}
inline void GlopParameters::set_use_dual_simplex(bool value) {
  _internal_set_use_dual_simplex(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_dual_simplex)
}

// optional bool allow_simplex_algorithm_change = 32 [default = false];
inline bool GlopParameters::_internal_has_allow_simplex_algorithm_change() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GlopParameters::has_allow_simplex_algorithm_change() const {
  return _internal_has_allow_simplex_algorithm_change();
}
inline void GlopParameters::clear_allow_simplex_algorithm_change() {
  allow_simplex_algorithm_change_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GlopParameters::_internal_allow_simplex_algorithm_change() const {
  return allow_simplex_algorithm_change_;
}
inline bool GlopParameters::allow_simplex_algorithm_change() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.allow_simplex_algorithm_change)
  return _internal_allow_simplex_algorithm_change();
}
inline void GlopParameters::_internal_set_allow_simplex_algorithm_change(bool value) {
  _has_bits_[0] |= 0x00000002u;
  allow_simplex_algorithm_change_ = value;
}
inline void GlopParameters::set_allow_simplex_algorithm_change(bool value) {
  _internal_set_allow_simplex_algorithm_change(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.allow_simplex_algorithm_change)
}

// optional int32 devex_weights_reset_period = 33 [default = 150];
inline bool GlopParameters::_internal_has_devex_weights_reset_period() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool GlopParameters::has_devex_weights_reset_period() const {
  return _internal_has_devex_weights_reset_period();
}
inline void GlopParameters::clear_devex_weights_reset_period() {
  devex_weights_reset_period_ = 150;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::_internal_devex_weights_reset_period() const {
  return devex_weights_reset_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::devex_weights_reset_period() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.devex_weights_reset_period)
  return _internal_devex_weights_reset_period();
}
inline void GlopParameters::_internal_set_devex_weights_reset_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x20000000u;
  devex_weights_reset_period_ = value;
}
inline void GlopParameters::set_devex_weights_reset_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_devex_weights_reset_period(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.devex_weights_reset_period)
}

// optional bool use_preprocessing = 34 [default = true];
inline bool GlopParameters::_internal_has_use_preprocessing() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool GlopParameters::has_use_preprocessing() const {
  return _internal_has_use_preprocessing();
}
inline void GlopParameters::clear_use_preprocessing() {
  use_preprocessing_ = true;
  _has_bits_[1] &= ~0x00000008u;
}
inline bool GlopParameters::_internal_use_preprocessing() const {
  return use_preprocessing_;
}
inline bool GlopParameters::use_preprocessing() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_preprocessing)
  return _internal_use_preprocessing();
}
inline void GlopParameters::_internal_set_use_preprocessing(bool value) {
  _has_bits_[1] |= 0x00000008u;
  use_preprocessing_ = value;
}
inline void GlopParameters::set_use_preprocessing(bool value) {
  _internal_set_use_preprocessing(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_preprocessing)
}

// optional bool use_middle_product_form_update = 35 [default = true];
inline bool GlopParameters::_internal_has_use_middle_product_form_update() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool GlopParameters::has_use_middle_product_form_update() const {
  return _internal_has_use_middle_product_form_update();
}
inline void GlopParameters::clear_use_middle_product_form_update() {
  use_middle_product_form_update_ = true;
  _has_bits_[1] &= ~0x00000010u;
}
inline bool GlopParameters::_internal_use_middle_product_form_update() const {
  return use_middle_product_form_update_;
}
inline bool GlopParameters::use_middle_product_form_update() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_middle_product_form_update)
  return _internal_use_middle_product_form_update();
}
inline void GlopParameters::_internal_set_use_middle_product_form_update(bool value) {
  _has_bits_[1] |= 0x00000010u;
  use_middle_product_form_update_ = value;
}
inline void GlopParameters::set_use_middle_product_form_update(bool value) {
  _internal_set_use_middle_product_form_update(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_middle_product_form_update)
}

// optional bool initialize_devex_with_column_norms = 36 [default = true];
inline bool GlopParameters::_internal_has_initialize_devex_with_column_norms() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool GlopParameters::has_initialize_devex_with_column_norms() const {
  return _internal_has_initialize_devex_with_column_norms();
}
inline void GlopParameters::clear_initialize_devex_with_column_norms() {
  initialize_devex_with_column_norms_ = true;
  _has_bits_[1] &= ~0x00000020u;
}
inline bool GlopParameters::_internal_initialize_devex_with_column_norms() const {
  return initialize_devex_with_column_norms_;
}
inline bool GlopParameters::initialize_devex_with_column_norms() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.initialize_devex_with_column_norms)
  return _internal_initialize_devex_with_column_norms();
}
inline void GlopParameters::_internal_set_initialize_devex_with_column_norms(bool value) {
  _has_bits_[1] |= 0x00000020u;
  initialize_devex_with_column_norms_ = value;
}
inline void GlopParameters::set_initialize_devex_with_column_norms(bool value) {
  _internal_set_initialize_devex_with_column_norms(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.initialize_devex_with_column_norms)
}

// optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
inline bool GlopParameters::_internal_has_exploit_singleton_column_in_initial_basis() const {
  bool value = (_has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool GlopParameters::has_exploit_singleton_column_in_initial_basis() const {
  return _internal_has_exploit_singleton_column_in_initial_basis();
}
inline void GlopParameters::clear_exploit_singleton_column_in_initial_basis() {
  exploit_singleton_column_in_initial_basis_ = true;
  _has_bits_[1] &= ~0x00000400u;
}
inline bool GlopParameters::_internal_exploit_singleton_column_in_initial_basis() const {
  return exploit_singleton_column_in_initial_basis_;
}
inline bool GlopParameters::exploit_singleton_column_in_initial_basis() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.exploit_singleton_column_in_initial_basis)
  return _internal_exploit_singleton_column_in_initial_basis();
}
inline void GlopParameters::_internal_set_exploit_singleton_column_in_initial_basis(bool value) {
  _has_bits_[1] |= 0x00000400u;
  exploit_singleton_column_in_initial_basis_ = value;
}
inline void GlopParameters::set_exploit_singleton_column_in_initial_basis(bool value) {
  _internal_set_exploit_singleton_column_in_initial_basis(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.exploit_singleton_column_in_initial_basis)
}

// optional double dual_small_pivot_threshold = 38 [default = 0.0001];
inline bool GlopParameters::_internal_has_dual_small_pivot_threshold() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool GlopParameters::has_dual_small_pivot_threshold() const {
  return _internal_has_dual_small_pivot_threshold();
}
inline void GlopParameters::clear_dual_small_pivot_threshold() {
  dual_small_pivot_threshold_ = 0.0001;
  _has_bits_[0] &= ~0x40000000u;
}
inline double GlopParameters::_internal_dual_small_pivot_threshold() const {
  return dual_small_pivot_threshold_;
}
inline double GlopParameters::dual_small_pivot_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dual_small_pivot_threshold)
  return _internal_dual_small_pivot_threshold();
}
inline void GlopParameters::_internal_set_dual_small_pivot_threshold(double value) {
  _has_bits_[0] |= 0x40000000u;
  dual_small_pivot_threshold_ = value;
}
inline void GlopParameters::set_dual_small_pivot_threshold(double value) {
  _internal_set_dual_small_pivot_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dual_small_pivot_threshold)
}

// optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
inline bool GlopParameters::_internal_has_preprocessor_zero_tolerance() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool GlopParameters::has_preprocessor_zero_tolerance() const {
  return _internal_has_preprocessor_zero_tolerance();
}
inline void GlopParameters::clear_preprocessor_zero_tolerance() {
  preprocessor_zero_tolerance_ = 1e-09;
  _has_bits_[0] &= ~0x80000000u;
}
inline double GlopParameters::_internal_preprocessor_zero_tolerance() const {
  return preprocessor_zero_tolerance_;
}
inline double GlopParameters::preprocessor_zero_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.preprocessor_zero_tolerance)
  return _internal_preprocessor_zero_tolerance();
}
inline void GlopParameters::_internal_set_preprocessor_zero_tolerance(double value) {
  _has_bits_[0] |= 0x80000000u;
  preprocessor_zero_tolerance_ = value;
}
inline void GlopParameters::set_preprocessor_zero_tolerance(double value) {
  _internal_set_preprocessor_zero_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.preprocessor_zero_tolerance)
}

// optional double objective_lower_limit = 40 [default = -inf];
inline bool GlopParameters::_internal_has_objective_lower_limit() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool GlopParameters::has_objective_lower_limit() const {
  return _internal_has_objective_lower_limit();
}
inline void GlopParameters::clear_objective_lower_limit() {
  objective_lower_limit_ = -std::numeric_limits<double>::infinity();
  _has_bits_[1] &= ~0x00000001u;
}
inline double GlopParameters::_internal_objective_lower_limit() const {
  return objective_lower_limit_;
}
inline double GlopParameters::objective_lower_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.objective_lower_limit)
  return _internal_objective_lower_limit();
}
inline void GlopParameters::_internal_set_objective_lower_limit(double value) {
  _has_bits_[1] |= 0x00000001u;
  objective_lower_limit_ = value;
}
inline void GlopParameters::set_objective_lower_limit(double value) {
  _internal_set_objective_lower_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.objective_lower_limit)
}

// optional double objective_upper_limit = 41 [default = inf];
inline bool GlopParameters::_internal_has_objective_upper_limit() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool GlopParameters::has_objective_upper_limit() const {
  return _internal_has_objective_upper_limit();
}
inline void GlopParameters::clear_objective_upper_limit() {
  objective_upper_limit_ = std::numeric_limits<double>::infinity();
  _has_bits_[1] &= ~0x00000002u;
}
inline double GlopParameters::_internal_objective_upper_limit() const {
  return objective_upper_limit_;
}
inline double GlopParameters::objective_upper_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.objective_upper_limit)
  return _internal_objective_upper_limit();
}
inline void GlopParameters::_internal_set_objective_upper_limit(double value) {
  _has_bits_[1] |= 0x00000002u;
  objective_upper_limit_ = value;
}
inline void GlopParameters::set_objective_upper_limit(double value) {
  _internal_set_objective_upper_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.objective_upper_limit)
}

// optional double degenerate_ministep_factor = 42 [default = 0.01];
inline bool GlopParameters::_internal_has_degenerate_ministep_factor() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool GlopParameters::has_degenerate_ministep_factor() const {
  return _internal_has_degenerate_ministep_factor();
}
inline void GlopParameters::clear_degenerate_ministep_factor() {
  degenerate_ministep_factor_ = 0.01;
  _has_bits_[1] &= ~0x00000080u;
}
inline double GlopParameters::_internal_degenerate_ministep_factor() const {
  return degenerate_ministep_factor_;
}
inline double GlopParameters::degenerate_ministep_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.degenerate_ministep_factor)
  return _internal_degenerate_ministep_factor();
}
inline void GlopParameters::_internal_set_degenerate_ministep_factor(double value) {
  _has_bits_[1] |= 0x00000080u;
  degenerate_ministep_factor_ = value;
}
inline void GlopParameters::set_degenerate_ministep_factor(double value) {
  _internal_set_degenerate_ministep_factor(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.degenerate_ministep_factor)
}

// optional int32 random_seed = 43 [default = 1];
inline bool GlopParameters::_internal_has_random_seed() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool GlopParameters::has_random_seed() const {
  return _internal_has_random_seed();
}
inline void GlopParameters::clear_random_seed() {
  random_seed_ = 1;
  _has_bits_[1] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::_internal_random_seed() const {
  return random_seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::random_seed() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.random_seed)
  return _internal_random_seed();
}
inline void GlopParameters::_internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000040u;
  random_seed_ = value;
}
inline void GlopParameters::set_random_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.random_seed)
}

// optional int32 num_omp_threads = 44 [default = 1];
inline bool GlopParameters::_internal_has_num_omp_threads() const {
  bool value = (_has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool GlopParameters::has_num_omp_threads() const {
  return _internal_has_num_omp_threads();
}
inline void GlopParameters::clear_num_omp_threads() {
  num_omp_threads_ = 1;
  _has_bits_[1] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::_internal_num_omp_threads() const {
  return num_omp_threads_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GlopParameters::num_omp_threads() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.num_omp_threads)
  return _internal_num_omp_threads();
}
inline void GlopParameters::_internal_set_num_omp_threads(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000200u;
  num_omp_threads_ = value;
}
inline void GlopParameters::set_num_omp_threads(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_omp_threads(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.num_omp_threads)
}

// optional bool perturb_costs_in_dual_simplex = 53 [default = false];
inline bool GlopParameters::_internal_has_perturb_costs_in_dual_simplex() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GlopParameters::has_perturb_costs_in_dual_simplex() const {
  return _internal_has_perturb_costs_in_dual_simplex();
}
inline void GlopParameters::clear_perturb_costs_in_dual_simplex() {
  perturb_costs_in_dual_simplex_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GlopParameters::_internal_perturb_costs_in_dual_simplex() const {
  return perturb_costs_in_dual_simplex_;
}
inline bool GlopParameters::perturb_costs_in_dual_simplex() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.perturb_costs_in_dual_simplex)
  return _internal_perturb_costs_in_dual_simplex();
}
inline void GlopParameters::_internal_set_perturb_costs_in_dual_simplex(bool value) {
  _has_bits_[0] |= 0x00000004u;
  perturb_costs_in_dual_simplex_ = value;
}
inline void GlopParameters::set_perturb_costs_in_dual_simplex(bool value) {
  _internal_set_perturb_costs_in_dual_simplex(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.perturb_costs_in_dual_simplex)
}

// optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
inline bool GlopParameters::_internal_has_use_dedicated_dual_feasibility_algorithm() const {
  bool value = (_has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool GlopParameters::has_use_dedicated_dual_feasibility_algorithm() const {
  return _internal_has_use_dedicated_dual_feasibility_algorithm();
}
inline void GlopParameters::clear_use_dedicated_dual_feasibility_algorithm() {
  use_dedicated_dual_feasibility_algorithm_ = true;
  _has_bits_[1] &= ~0x00000800u;
}
inline bool GlopParameters::_internal_use_dedicated_dual_feasibility_algorithm() const {
  return use_dedicated_dual_feasibility_algorithm_;
}
inline bool GlopParameters::use_dedicated_dual_feasibility_algorithm() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_dedicated_dual_feasibility_algorithm)
  return _internal_use_dedicated_dual_feasibility_algorithm();
}
inline void GlopParameters::_internal_set_use_dedicated_dual_feasibility_algorithm(bool value) {
  _has_bits_[1] |= 0x00000800u;
  use_dedicated_dual_feasibility_algorithm_ = value;
}
inline void GlopParameters::set_use_dedicated_dual_feasibility_algorithm(bool value) {
  _internal_set_use_dedicated_dual_feasibility_algorithm(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_dedicated_dual_feasibility_algorithm)
}

// optional double relative_cost_perturbation = 54 [default = 1e-05];
inline bool GlopParameters::_internal_has_relative_cost_perturbation() const {
  bool value = (_has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool GlopParameters::has_relative_cost_perturbation() const {
  return _internal_has_relative_cost_perturbation();
}
inline void GlopParameters::clear_relative_cost_perturbation() {
  relative_cost_perturbation_ = 1e-05;
  _has_bits_[1] &= ~0x00002000u;
}
inline double GlopParameters::_internal_relative_cost_perturbation() const {
  return relative_cost_perturbation_;
}
inline double GlopParameters::relative_cost_perturbation() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.relative_cost_perturbation)
  return _internal_relative_cost_perturbation();
}
inline void GlopParameters::_internal_set_relative_cost_perturbation(double value) {
  _has_bits_[1] |= 0x00002000u;
  relative_cost_perturbation_ = value;
}
inline void GlopParameters::set_relative_cost_perturbation(double value) {
  _internal_set_relative_cost_perturbation(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.relative_cost_perturbation)
}

// optional double relative_max_cost_perturbation = 55 [default = 1e-07];
inline bool GlopParameters::_internal_has_relative_max_cost_perturbation() const {
  bool value = (_has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool GlopParameters::has_relative_max_cost_perturbation() const {
  return _internal_has_relative_max_cost_perturbation();
}
inline void GlopParameters::clear_relative_max_cost_perturbation() {
  relative_max_cost_perturbation_ = 1e-07;
  _has_bits_[1] &= ~0x00004000u;
}
inline double GlopParameters::_internal_relative_max_cost_perturbation() const {
  return relative_max_cost_perturbation_;
}
inline double GlopParameters::relative_max_cost_perturbation() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.relative_max_cost_perturbation)
  return _internal_relative_max_cost_perturbation();
}
inline void GlopParameters::_internal_set_relative_max_cost_perturbation(double value) {
  _has_bits_[1] |= 0x00004000u;
  relative_max_cost_perturbation_ = value;
}
inline void GlopParameters::set_relative_max_cost_perturbation(double value) {
  _internal_set_relative_max_cost_perturbation(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.relative_max_cost_perturbation)
}

// optional double initial_condition_number_threshold = 59 [default = 1e+50];
inline bool GlopParameters::_internal_has_initial_condition_number_threshold() const {
  bool value = (_has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool GlopParameters::has_initial_condition_number_threshold() const {
  return _internal_has_initial_condition_number_threshold();
}
inline void GlopParameters::clear_initial_condition_number_threshold() {
  initial_condition_number_threshold_ = 1e+50;
  _has_bits_[1] &= ~0x00040000u;
}
inline double GlopParameters::_internal_initial_condition_number_threshold() const {
  return initial_condition_number_threshold_;
}
inline double GlopParameters::initial_condition_number_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.initial_condition_number_threshold)
  return _internal_initial_condition_number_threshold();
}
inline void GlopParameters::_internal_set_initial_condition_number_threshold(double value) {
  _has_bits_[1] |= 0x00040000u;
  initial_condition_number_threshold_ = value;
}
inline void GlopParameters::set_initial_condition_number_threshold(double value) {
  _internal_set_initial_condition_number_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.initial_condition_number_threshold)
}

// optional bool log_search_progress = 61 [default = false];
inline bool GlopParameters::_internal_has_log_search_progress() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GlopParameters::has_log_search_progress() const {
  return _internal_has_log_search_progress();
}
inline void GlopParameters::clear_log_search_progress() {
  log_search_progress_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GlopParameters::_internal_log_search_progress() const {
  return log_search_progress_;
}
inline bool GlopParameters::log_search_progress() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.log_search_progress)
  return _internal_log_search_progress();
}
inline void GlopParameters::_internal_set_log_search_progress(bool value) {
  _has_bits_[0] |= 0x00000008u;
  log_search_progress_ = value;
}
inline void GlopParameters::set_log_search_progress(bool value) {
  _internal_set_log_search_progress(value);
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.log_search_progress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace glop
}  // namespace operations_research

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_ScalingAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_ScalingAlgorithm>() {
  return ::operations_research::glop::GlopParameters_ScalingAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_SolverBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_SolverBehavior>() {
  return ::operations_research::glop::GlopParameters_SolverBehavior_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_PricingRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_PricingRule>() {
  return ::operations_research::glop::GlopParameters_PricingRule_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_InitialBasisHeuristic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_InitialBasisHeuristic>() {
  return ::operations_research::glop::GlopParameters_InitialBasisHeuristic_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_CostScalingAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_CostScalingAlgorithm>() {
  return ::operations_research::glop::GlopParameters_CostScalingAlgorithm_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ortools_2fglop_2fparameters_2eproto
